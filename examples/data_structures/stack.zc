
import "std.zc"

struct Stack<T> {
    data: Vec<T>;
}

impl Stack<T> {
    fn new() -> Self {
        return Self { data: Vec<T>::new() };
    }
    
    fn push(self, item: T) {
        self.data.push(item);
    }
    
    fn pop(self) -> Option<T> {
        if self.data.length() == 0 {
            return Option<T>::None();
        }
        return Option<T>::Some(self.data.pop());
    }
    
    fn peek(self) -> Option<T> {
        if self.data.length() == 0 {
            return Option<T>::None();
        }
        return Option<T>::Some(self.data.last());
    }
    
    fn is_empty(self) -> bool {
        return self.data.length() == 0;
    }
    
    fn size(self) -> usize {
        return self.data.length();
    }
    
    fn free(self) {
        self.data.free();
    }
}

fn main() {
    "[Integer Stack]";
    let int_stack = Stack<int>::new();
    defer int_stack.free();   
 
    "Pushing: 10, 20, 30";
    int_stack.push(10);
    int_stack.push(20);
    int_stack.push(30);
    
    "Size: {int_stack.size()}";
    let p = int_stack.peek();
    "Peek: {p.unwrap()}";
    
    "Popping: "..;
    while !int_stack.is_empty() {
        let opt = int_stack.pop();
        "{opt.unwrap()} "..;
    }
    "";
    
    "";
    "[String Stack]";
    let str_stack = Stack<String>::new();
    defer str_stack.free();   
 
    str_stack.push(String::new("First"));
    str_stack.push(String::new("Second"));
    str_stack.push(String::new("Third"));
    
    "Popping: "..;
    while !str_stack.is_empty() {
        let opt_s = str_stack.pop();
        let s: String = opt_s.unwrap();
        "{s.c_str()} "..;
    }
    "";
}
