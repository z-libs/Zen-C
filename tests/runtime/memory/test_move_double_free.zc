import "../../../std/mem.zc"

// Global counters to track drop calls
let DROP_COUNT = 0;
let DROP_NULL_COUNT = 0;

struct Resource {
    data: int*;
    id: int;
}

impl Drop for Resource {
    fn drop(self) {
        if (self.data != NULL) {
            DROP_COUNT = DROP_COUNT + 1;
            free(self.data);
            self.data = NULL; // Prevent double free logic if called again, though generated code should zero
        } else {
            DROP_NULL_COUNT = DROP_NULL_COUNT + 1;
        }
    }
}

struct Container {
    res: Resource;
}

// No explicit Drop for Container, relies on compiler generating one

test "move_variable" {
    DROP_COUNT = 0;
    DROP_NULL_COUNT = 0;
    
    {
        let r1 = Resource { data: malloc(10), id: 1 };
        let r2 = r1; // Move
        
        // r1 should be nullified
        // r2 owns data
    }

    assert(DROP_COUNT == 1, "Should drop exactly once (r2)");
    assert(DROP_NULL_COUNT == 0, "Should see ZERO null drops (r1 flag skipped)");
}

fn pass_through(r: Resource) -> Resource {
    return r; // Move return
}

test "move_function" {
    DROP_COUNT = 0;
    DROP_NULL_COUNT = 0;

    {
        let r1 = Resource { data: malloc(10), id: 2 };
        let r2 = pass_through(r1); 
        // r1 moved to arg -> moved to return -> moved to r2
    }
    
    // r1: null drop
    // arg: null drop (moved to return)
    // return temp: null drop (moved to r2)
    // r2: valid drop
    
    assert(DROP_COUNT == 1, "Should drop exactly once (final r2)");
    // r1 is skipped (flag). Arg might be skipped or null-dropped depending on arg impl.
    // We just verify valid drop count is correct.
    // assert(DROP_NULL_COUNT >= 0, "Null drops allowed but not required for locals"); 
}

test "partial_move_member" {
    DROP_COUNT = 0;
    DROP_NULL_COUNT = 0;

    {
        let c = Container { res: Resource { data: malloc(10), id: 3 } };
        let r = c.res; // Partial move
        
        // c.res should be nullified
        // r owns data
    }
    
    // r drops valid
    // c drops, checks res -> null drop
    
    assert(DROP_COUNT == 1, "Should drop exactly once (r)");
    // Container generated destructor now correctly calls field destructors!
    // Since c.res was moved, its data is null, causing 1 null drop.
    assert(DROP_NULL_COUNT == 1, "Container should drop moved res (null drop)");
}
