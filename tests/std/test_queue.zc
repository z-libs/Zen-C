import "std/queue.zc"

test "Queue Push/Pop" {
  println "Testing Queue Push/Pop";
  let queue = Queue<i32>::new();
  defer queue.free();

  println "Popping on an empty queue without pushing anything prior"
  let v = queue.pop();
  assert(v.is_none(), "v should not have a valid value");

  println "Pushing in three values..."
  queue.push(123);
  queue.push(456);
  queue.push(789);
  
  v = queue.pop();
  assert(v.is_some() && v.unwrap() == 123, "v's value should be 123");

  v = queue.pop();
  assert(v.is_some() && v.unwrap() == 456, "v's value should be 456");

  v = queue.pop();
  assert(v.is_some() && v.unwrap() == 789, "v's value should be 789");

  println "Popping on an empty queue after pushing and popping three values"
  v = queue.pop();
  assert(v.is_none(), "v should not have a valid value");
}

test "Queue Length and Clear" {
  println "Testing Queue clear";
  let queue = Queue<i32>::new();
  defer queue.free();

  assert(queue.is_empty() && queue.length() == 0, "queue should be empty");

  queue.push(123);
  assert(!queue.is_empty() && queue.length() == 1, "queue should have 1 value");

  queue.clear();
  assert(queue.is_empty() && queue.length() == 0, "queue should be empty");
}

test "Queue Clone" {
  println "Testing Queue Cloning";
  let queue = Queue<i32>::new();
  defer queue.free();
  queue.push(123);
  let queue2 = queue.clone();
  defer queue2.free();

  let v = queue2.pop();
  assert(v.is_some() && v.unwrap() == 123, "v's value should be 123");
  v = queue2.pop();
  assert(v.is_none(), "v should not have a valid value");

  v = queue.pop();
  assert(v.is_some() && v.unwrap() == 123, "v's value should be 123");
  v = queue.pop();
  assert(v.is_none(), "v should not have a valid value");
}

test "Queue Ring Buffer (Advanced)" {
    let q = Queue<int>::new();
    
    println "Fill slightly"
    q.push(1);
    q.push(2);
    q.push(3);
    assert(*q.pop().unwrap_ref() == 1);
    
    println "Pushing until capacity (assume 8)"
    q.push(4); q.push(5); q.push(6); q.push(7); q.push(8); q.push(9);
    
    println "Popping some to advance head"
    assert(*q.pop().unwrap_ref() == 2);
    assert(*q.pop().unwrap_ref() == 3);
    
    println "Pushing to wrap tail"
    q.push(10);
    q.push(11);
    
    while (!q.is_empty()) {
        q.pop();
    }
    
    println "Testing clear"
    q.push(100);
    q.clear();
    assert(q.is_empty());
    
    println "Large scale test"
    for (let i = 0; i < 100; i=i+1) {
        q.push(i);
    }
    for (let i = 0; i < 100; i=i+1) {
        assert(*q.pop().unwrap_ref() == i);
    }
    
    q.free();
}
