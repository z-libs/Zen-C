
struct Point {
    x: int;
}

struct Mover {
    val: int;
}

test "basic_move" {
    let p1 = Mover { val: 10 };
    let p2 = p1; // p1 moved to p2
    
    // Valid usage of p2
    assert(p2.val == 10, "p2 should be valid");

    // Invalid usage of p1 (Uncomment to test compiler error)
    // let p3 = p1; 
}

test "primitive_copy" {
    let i = 10;
    let j = i; // Copy
    let k = i; // Copy again - should be valid
    assert(k == 10, "Primitive copy failed");
}

test "reassignment" {
    let m1 = Mover { val: 1 };
    let m2 = m1; // m1 moved
    
    m1 = Mover { val: 2 }; // Resurrect m1
    let m3 = m1; // Valid now
    assert(m3.val == 2, "Resurrection failed");
}

fn consume(m: Mover) {
    assert(m.val == 10, "Func arg failed");
}

test "func_arg" {
    let m = Mover { val: 10 };
    consume(m); // m moved
    
    // 2. Use after move (Call - Negative Test)
    // consume(m); // Should fail: Use of moved value 'm'
}

/*
// 3. Use after return (Negative Test)
fn fail_return(m: Mover) -> Mover {
    let m2 = m;
    return m; // Should fail: Use of moved value 'm'
}
*/
