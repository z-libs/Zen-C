
import "std.zc"

// Empty struct
@derive(Eq, Clone)
struct Empty {}

fn test_empty_struct() {
    let e1 = Empty {};
    let e2 = Empty {};
    
    if (!e1.eq(&e2)) {
        println "FAIL: Empty struct eq failed";
        exit(1);
    }
    
    println "  -> Empty struct with @derive(Eq) works";
}

// Struct with many fields (stress @derive(Eq))
@derive(Eq)
struct ManyFields {
    a: int;
    b: int;
    c: int;
    d: int;
    e: int;
    f: int;
    g: int;
    h: int;
}

fn test_many_fields() {
    let m1 = ManyFields { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7, h: 8 };
    let m2 = ManyFields { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7, h: 8 };
    let m3 = ManyFields { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7, h: 9 }; // h differs
    
    if (!m1.eq(&m2)) {
        println "FAIL: equal structs not detected as equal";
        exit(1);
    }
    
    if (m1.eq(&m3)) {
        println "FAIL: different structs detected as equal";
        exit(1);
    }
    
    println "  -> ManyFields @derive(Eq) works correctly";
}

// Pointer to struct equality (should use ==, not _eq)
struct Point {
    x: int;
    y: int;
}

fn test_pointer_equality() {
    let p1 = Point { x: 1, y: 2 };
    let ptr1: Point* = &p1;
    let ptr2: Point* = &p1;
    let p2 = Point { x: 1, y: 2 };
    let ptr3: Point* = &p2;
    
    // Same pointer should be equal
    if (ptr1 != ptr2) {
        println "FAIL: same pointer not equal";
        exit(1);
    }
    
    // Different pointers (even to equal values) should not be pointer-equal
    if (ptr1 == ptr3) {
        println "FAIL: different pointers compare equal";
        exit(1);
    }
    
    print "  -> Pointer equality uses == not _eq";
}

// Very long string
fn test_long_string() {
    let s = String::from("This is a very long string that should test the string handling capabilities of the compiler and make sure that buffer allocations are correct and that there are no overflow issues with long strings.");
    
    if (s.length() < 100) {
        println "FAIL: long string length incorrect";
        exit(1);
    }
    
    print "  -> Long string handling works";
}

// Null pointer handling
fn test_null_pointer() {
    let ptr: int* = NULL;
    
    if (ptr != NULL) {
        println "FAIL: NULL pointer check failed";
        exit(1);
    }
    
    println "  -> NULL pointer handling works";
}

// Numeric edge cases
fn test_numeric_edges() {
    let max_int: int = 2147483647;
    let min_int: int = -1000000000;
    
    if (max_int <= 0) {
        println "FAIL: max_int is wrong";
        exit(1);
    }
    
    if (min_int >= 0) {
        println "FAIL: min_int is wrong";
        exit(1);
    }
    
    println "  -> Numeric edge cases work";
}

// Boolean operations
fn test_boolean_ops() {
    let a = true;
    let b = false;
    
    if (!(a && !b)) {
        println "FAIL: boolean AND failed";
        exit(1);
    }
    
    if (!(a || b)) {
        println "FAIL: boolean OR failed";
        exit(1);
    }
    
    println "  -> Boolean operations work\n";
}

test "test_edge_cases" {
    println "Running edge case tests...";
    
    test_empty_struct();
    test_many_fields();
    test_pointer_equality();
    test_long_string();
    test_null_pointer();
    test_numeric_edges();
    test_boolean_ops();
    
    println "All edge case tests passed!";
}
