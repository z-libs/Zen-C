
fn classify_number(n: int) -> int {
    match n {
        0 => { return 100; },
        1 => { return 200; },
        2 => { return 300; },
        _ => { return -1; }
    }
}

fn get_sign(n: int) -> string {
    match n {
        0 => { return "zero"; },
        _ => {
            if (n > 0) {
                return "positive";
            }
            return "negative";
        }
    }
}

fn classify_extended(n: int) -> int {
    match n {
        1 || 2 => { return 100; },      // OR pattern with ||
        3 or 4 => { return 200; },       // OR pattern with 'or'
        5..<8 => { return 300; },        // Use ..< for exclusive range (originally 5..8)
        8..8 => { return 305; },         // Single valid? (empty range)
        10..=15 => { return 400; },      // Range inclusive (10-15)
        _ => { return -1; }
    }
}

test "test_match" {
    println "Testing match expressions...";
    
    // Match with exact value (0)
    let res1 = classify_number(0);
    if (res1 == 100) {
        println "  -> match 0: Passed";
    } else {
        println "  -> match 0: Failed";
        exit(1);
    }
    
    // Match with exact value (1)
    let res2 = classify_number(1);
    if (res2 == 200) {
        println "  -> match 1: Passed";
    } else {
        println "  -> match 1: Failed";
        exit(1);
    }
    
    // Match with exact value (2)
    let res3 = classify_number(2);
    if (res3 == 300) {
        println "  -> match 2: Passed";
    } else {
        println "  -> match 2: Failed";
        exit(1);
    }
    
    // Match with default case
    let res4 = classify_number(99);
    if (res4 == -1) {
        println "  -> match default: Passed";
    } else {
        println "  -> match default: Failed";
        exit(1);
    }
    
    // Match with complex body (zero)
    let sign1 = get_sign(0);
    if (strcmp(sign1, "zero") == 0) {
        println "  -> match complex (zero): Passed";
    } else {
        println "  -> match complex (zero): Failed";
        exit(1);
    }
    
    // Match with complex body (positive)
    let sign2 = get_sign(42);
    if (strcmp(sign2, "positive") == 0) {
        println "  -> match complex (positive): Passed";
    } else {
        println "  -> match complex (positive): Failed";
        exit(1);
    }
    
    // Match with complex body (negative)
    let sign3 = get_sign(-10);
    if (strcmp(sign3, "negative") == 0) {
        println "  -> match complex (negative): Passed";
    } else {
        println "  -> match complex (negative): Failed";
        exit(1);
    }
    
    // OR pattern with ||
    let or1 = classify_extended(1);
    let or2 = classify_extended(2);
    if (or1 == 100 && or2 == 100) {
        println "  -> match OR (||): Passed";
    } else {
        println "  -> match OR (||): Failed";
        exit(1);
    }
    
    // OR pattern with 'or'
    let or3 = classify_extended(3);
    let or4 = classify_extended(4);
    if (or3 == 200 && or4 == 200) {
        println "  -> match OR (or): Passed";
    } else {
        println "  -> match OR (or): Failed";
        exit(1);
    }
    
    // Range exclusive (5..8 matches 5, 6, 7)
    let r5 = classify_extended(5);
    let r7 = classify_extended(7);
    let r8 = classify_extended(8);  // Should NOT match
    if (r5 == 300 && r7 == 300 && r8 == -1) {
        println "  -> match range exclusive: Passed";
    } else {
        println "  -> match range exclusive: Failed";
        exit(1);
    }
    
    // Range inclusive (10..=15 matches 10-15)
    let r10 = classify_extended(10);
    let r15 = classify_extended(15);
    let r16 = classify_extended(16);  // Should NOT match
    if (r10 == 400 && r15 == 400 && r16 == -1) {
        println "  -> match range inclusive: Passed";
    } else {
        println "  -> match range inclusive: Failed";
        exit(1);
    }
    
    println "All match tests passed!";
    
}
