
struct Pair<A, B> {
    first: A;
    second: B;
}

struct Triple<A, B, C> {
    first: A;
    second: B;
    third: C;
}

// Generic function with 2 type parameters
fn make_pair<F, S>(f: F, s: S) -> Pair<F, S> {
    return Pair<F, S> { first: f, second: s };
}

// Generic function with 3 type parameters
fn make_triple<X, Y, Z>(x: X, y: Y, z: Z) -> Triple<X, Y, Z> {
    return Triple<X, Y, Z> { first: x, second: y, third: z };
}

test "multi-type generics basic" {
    let p: Pair<int, float>;
    p.first = 42;
    p.second = 3.14;
    assert(p.first == 42, "First field failed");
    println "Multi-type generics test passed!";
}

test "generic function with 2 params" {
    let p = make_pair<int, float>(100, 2.5);
    assert(p.first == 100, "Pair first failed");
    println "2-param generic function passed!";
}

test "generic function with 3 params" {
    let t = make_triple<int, float, bool>(42, 3.14, true);
    assert(t.first == 42, "Triple first failed");
    assert(t.third == true, "Triple third failed");
    println "3-param generic function passed!";
}
