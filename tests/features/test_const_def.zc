
test "def_constants" {
    def PI = 3.14159;
    def MAX = 100;
    
    assert(MAX == 100, "def constant value mismatch");
    // PI check (float) - exact match might be tricky but 3.14159 is literal
    
    let x = MAX; 
    assert(x == 100, "Assign from def");
}

test "def_scoping" {
    def VAL = 1;
    {
        def VAL = 2; // Shadowing
        assert(VAL == 2, "Shadowed def");
    }
    assert(VAL == 1, "Original def preserved");
}

test "const_type_qualifier" {
    let x: const int = 10;
    assert(x == 10, "const Var init");
    
    // Address of const let should be allowed
    let p: const int* = &x; 
    assert(*p == 10, "Pointer to const let");
}

// Note: Negative tests (compilation failures) are hard to test in this harness currently
// but we verified the logic in parser_expr.c
