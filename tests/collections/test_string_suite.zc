
include <string.h>
include <stdio.h>
import "std.zc"

test "test_string_methods" {
    println "Testing String methods...";
    
    // Substring
    let s1: String = String::from("Hello World");
    let sub: String = s1.substring(0, 5);
    let expected1: String = String::from("Hello");
    if (sub.eq(&expected1)) {
        println "  -> substring(0, 5): Passed";
    } else {
        assert(false, "substring(0, 5) failed");
    }
    
    // Substring middle
    let sub2: String = s1.substring(6, 5);
    let expected2: String = String::from("World");
    if (sub2.eq(&expected2)) {
        println "  -> substring(6, 5): Passed";
    } else {
        assert(false, "substring(6, 5) failed");
    }
    
    // Find character - found
    let pos: Option<usize> = s1.find('W');
    if (pos.is_some()) {
        let idx: usize = pos.unwrap();
        assert(idx == (usize)6, "find('W') index mismatch");
        println "  -> find('W'): Passed (found at index 6)";
    } else {
        assert(false, "find('W') failed (not found)");
    }
    
    // Find character - not found
    let pos2: Option<usize> = s1.find('Z');
    if (pos2.is_none()) {
        println "  -> find('Z'): Passed (not found)";
    } else {
        assert(false, "find('Z') failed (found unexpectedly)");
    }
    
    // Length
    let len: usize = s1.length();
    if (len == (usize)11) {
        println "  -> length(): Passed (11)";
    } else {
        assert(false, "length() failed");
    }
    
    // Contains
    if (s1.contains('W')) {
        println "  -> contains('W'): Passed";
    } else {
        assert(false, "contains('W') failed");
    }
    
    if (!s1.contains('Z')) {
        println "  -> !contains('Z'): Passed";
    } else {
        assert(false, "!contains('Z') failed");
    }

    // Append
    let s2: String = String::from("Hello");
    let s3: String = String::from(" World");
    s2.append(&s3);
    let expected6: String = String::from("Hello World");
    if (s2.eq(&expected6)) {
        println "  -> append(): Passed";
    } else {
        assert(false, "append() failed");
    }
    
    println "All String methods passed!";
}

test "test_fstrings_return" {
    println "Testing F-Strings and Returns...";
    let x = 100;
    let y = 50;

    println "Direct F-String: x={x}";
    let nested = f"y is {y}";
    println "Argument F-String: {nested}";
    println "Math inside: 100 + 50 = {x + y}";
    
    let inner = f"Inner({x})";
    let outer = f"Outer({inner})";
    println "Composed: {outer}";
    assert(strcmp(outer, "Outer(Inner(100))") == 0, "Composed f-string failed");
}

test "test_string_std_ops" {
    println "Testing String Std Ops...";
    let s1 = String::from("Hello");
    let s2 = String::from(" World");
    
    let s3 = s1.add(&s2); 
    
    print "Concatenated: ";
    s3.println();
    
    assert(s3.length() == 11, "Length mismatch");

    let s4 = String::from("Hello World");
    if (s3.eq(&s4)) {
        println "Equality check passed: Strings are identical.";
    } else {
        assert(false, "Equality check failed");
    }
}
