import "./core.zc"
import "./option.zc"
import "./string.zc"

raw {
    #ifdef _WIN32
    #include <stdlib.h>
    #endif
    char *_z_env_get(char *name) {
        return getenv(name);
    }

    int _z_env_set(char *name, char *value, int overwrite) {
    #ifdef _WIN32
        if (!overwrite) {
            // if already set, do nothing
            char *cur = getenv(name);
            if (cur != NULL) return 0;
        }
        // _putenv_s returns 0 on success
        return _putenv_s(name, value ? value : "");
    #else
        return setenv(name, value, overwrite);
    #endif
    }

    int _z_env_unset(char *name) {
    #ifdef _WIN32
        // In MS CRT, setting NAME= (empty) removes/clears it
        return _putenv_s(name, "");
    #else
        return unsetenv(name);
    #endif
    }

}

extern fn _z_env_get(name: char*) -> char*;
extern fn _z_env_set(name: char*, value: char*, overwrite: int) -> int;
extern fn _z_env_unset(name: char*) -> int;

@derive(Eq)
enum EnvRes {
    ERR,
    OK,
}

struct Env {}

impl Env {
    fn get(name: string) -> Option<string> {
        let value: string = _z_env_get(name);
        if (value == NULL) {
            return Option<string>::None();
        }

        return Option<string>::Some(value);
    }

    fn get_dup(name: string) -> Option<String> {
        let value: string = _z_env_get(name);
        if (value == NULL) {
            return Option<String>::None();
        }

        let v = String::from(value);
        let o = Option<String>::Some(v);
        v.forget();

        return o;
    }

    fn set(name: string, value: string) -> EnvRes {
        let ret: int = _z_env_set(name, value, 1);

        return (ret == 0) ? EnvRes::OK() : EnvRes::ERR();
    }

    fn unset(name: string) -> EnvRes {
        let ret: int = _z_env_unset(name);

        return (ret == 0) ? EnvRes::OK() : EnvRes::ERR();
    }
}
