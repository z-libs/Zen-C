import "./core.zc"
import "./vec.zc"
import "./option.zc"

struct String {
    vec: Vec<char>;
}

impl String {
    fn new(s: char*, allocator: Allocator = &GLOBAL_ALLOCATOR) -> String {
        var len = strlen(s);
        var v = Vec<char>::new(allocator);
        // Manual copy for now
        for (var i = 0; i < len; i = i + 1) {
            v.push(s[i]);
        }
        v.push(0);
        
        // Extract fields to transfer ownership
        var a = v.alloc;
        var d = v.data;
        var l = v.len;
        var c = v.cap;
        
        // Forget the local vector so it doesn't free the memory
        v.forget();
        
        return String { vec: Vec<char> {alloc: a, data: d, len: l, cap: c } };
    }

    fn from(s: char*, allocator: Allocator = &GLOBAL_ALLOCATOR) -> String {
        return String::new(s, allocator);
    }

    fn c_str(self) -> char* {
        return self.vec.data;
    }

    fn forget(self) {
        self.vec.forget();
    }
    
    fn append(self, other: String*) {
        // Remove null terminator before appending
        if (self.vec.len > 0) {
            self.vec.len = self.vec.len - 1;
        }
        
        var other_len = other.vec.len;
        for (var i = 0; i < other_len; i = i + 1) {
            self.vec.push(other.vec.get(i));
        }
    }

    fn add(self, other: String*) -> String {
        var new_s = String::from(self.c_str());
        new_s.append(other);
        
        var a = new_s.vec.alloc;
        var d = new_s.vec.data;
        var l = new_s.vec.len;
        var c = new_s.vec.cap;
        new_s.forget();
        
        return String { vec: Vec<char> {alloc: a, data: d, len: l, cap: c } };
    }

    fn eq(self, other: String*) -> bool {
        return strcmp(self.c_str(), (*other).c_str()) == 0;
    }

    fn length(self) -> usize {
        if (self.vec.len == 0) { return 0; }
        return self.vec.len - 1;
    }
    
    fn substring(self, start: usize, len: usize) -> String {
        if (start + len > self.length()) {
            panic("substring out of bounds");
        }
        var v = Vec<char>::new();
        for (var i: usize = 0; i < len; i = i + 1) {
             v.push(self.vec.get(start + i));
        }
        v.push(0);
        
        var a = v.alloc;
        var d = v.data;
        var l = v.len;
        var c = v.cap;
        v.forget();
        
        return String { vec: Vec<char> { alloc: a, data: d, len: l, cap: c } };
    }

    fn find(self, target: char) -> Option<usize> {
        var len = self.length();
        for (var i: usize = 0; i < len; i = i + 1) {
            if (self.vec.get(i) == target) {
                return Option<usize>::Some(i);
            }
        }
        return Option<usize>::None();
    }

    fn print(self) {
        printf("%s", self.c_str());
        fflush(stdout);
    }

    fn println(self) {
        printf("%s\n", self.c_str());
    }
    
    fn is_empty(self) -> bool {
        return self.length() == 0;
    }
    
    fn contains(self, target: char) -> bool {
        return self.find(target).is_some();
    }
    
    fn starts_with(self, prefix: char*) -> bool {
        var plen = strlen(prefix);
        if plen > self.length() { return false; }
        return strncmp(self.c_str(), prefix, plen) == 0;
    }
    
    fn ends_with(self, suffix: char*) -> bool {
        var slen = strlen(suffix);
        var len = self.length();
        if slen > len { return false; }
        var offset = (int)(len - slen);
        return strcmp(self.c_str() + offset, suffix) == 0;
    }

    fn _utf8_seq_len(first_byte: char) -> usize {
        var b = (int)first_byte;
        if ((b & 0x80) == 0) { return 1; }
        if ((b & 0xE0) == 0xC0) { return 2; }
        if ((b & 0xF0) == 0xE0) { return 3; }
        if ((b & 0xF8) == 0xF0) { return 4; }
        return 1; // Fallback
    }

    fn utf8_len(self) -> usize {
        var count: usize = 0;
        var i: usize = 0;
        var len = self.length();
        while i < len {
            var c = self.vec.get(i);
            i = i + String::_utf8_seq_len(c);
            count = count + 1;
        }
        return count;
    }

    fn utf8_at(self, idx: usize) -> String {
        var count: usize = 0;
        var i: usize = 0;
        var len = self.length();
        while i < len {
            var c = self.vec.get(i);
            var seq = String::_utf8_seq_len(c);
            
            if (count == idx) {
                return self.substring(i, seq);
            }
            
            i = i + seq;
            count = count + 1;
        }
        return String::new("");
    }

    fn utf8_substr(self, start_idx: usize, num_chars: usize) -> String {
        if (num_chars == 0) { return String::new(""); }

        var byte_start: usize = 0;
        var byte_len: usize = 0;
        
        var count: usize = 0;
        var i: usize = 0;
        var len = self.length();
        var found_start = false;
        
        while i < len {
            // Check if we reached the start char
            if (!found_start && count == start_idx) {
                byte_start = i;
                found_start = true;
                // Reset count to track chars collected
                count = 0; 
            } else if (!found_start) {
                 // Still seeking start
                 var c = self.vec.get(i);
                 i = i + String::_utf8_seq_len(c);
                 count = count + 1;
                 continue;
            }
            
            // If we are here, we are collecting chars
            if (count < num_chars) {
                var c = self.vec.get(i);
                var seq = String::_utf8_seq_len(c);
                byte_len = byte_len + seq;
                i = i + seq;
                count = count + 1;
            } else {
                break;
            }
        }
        
        if (!found_start) { return String::new(""); }
        
        return self.substring(byte_start, byte_len);
    }

    fn split(self, delim: char) -> Vec<String> {
        var parts = Vec<String>::new();
        var len = self.length();
        if (len == 0) { return parts; }

        var start: usize = 0;
        var i: usize = 0;
        
        while i < len {
            if (self.vec.get(i) == delim) {
                // Found delimiter
                parts.push(self.substring(start, i - start));
                start = i + 1;
            }
            i = i + 1;
        }
        
        // Push last segment
        if (start <= len) {
            parts.push(self.substring(start, len - start));
        }
        
        return parts;
    }

    fn trim(self) -> String {
        var start: usize = 0;
        var len = self.length();
        var end = len;

        // Find start
        while (start < len) {
            var c = self.vec.get(start);
            if (c != ' ' && c != '\t' && c != '\n' && c != '\r') {
                break;
            }
            start = start + 1;
        }

        if (start == len) {
            return String::new("");
        }

        // Find end
        while (end > start) {
            var c = self.vec.get(end - 1);
            if (c != ' ' && c != '\t' && c != '\n' && c != '\r') {
                break;
            }
            end = end - 1;
        }

        return self.substring(start, end - start);
    }
    
    fn replace(self, target: char*, replacement: char*) -> String {
        var t_len = strlen(target);
        if (t_len == 0) return self.substring(0, self.length()); // clone
        

        var s_len = self.length();
        var result = String::new("");
        
        var i: usize = 0;
        while (i < s_len) {
            // Check if match
            if (i + t_len <= s_len) {
                var is_match = true;
                // Manual strncmp against vec data
                for (var k: usize = 0; k < t_len; k = k + 1) {
                    if (self.vec.get(i + k) != target[k]) {
                        is_match = false;
                        break;
                    }
                }
                
                if (is_match) {
                    var r_str = String::new(replacement);
                    result.append(&r_str);
                    i = i + t_len;
                    continue;
                }
            }
            
            // Append single char
            var v = Vec<char>::new();
            v.push(self.vec.get(i));
            v.push(0);
            var ch_s = String::new(v.data);
            result.append(&ch_s);
            //v.free(); // The array should be cleaned up automatically.
            i = i + 1;
        }
        return result;
    }

    @deprecated("Strings are freed automatically.")
    fn free(self) {}
}