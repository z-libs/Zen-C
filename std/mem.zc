trait Allocator {
    fn alloc(self, size: usize) -> u8*;
    fn realloc(self, ptr: u8*, new_size: usize) -> u8*;
    fn free(self, ptr: u8*, size: usize);
}

struct GeneralAllocator {}

impl Allocator for GeneralAllocator {
    fn alloc(self, size: usize) -> u8* {
        raw {
            return (uint8_t*) malloc(size);
        }
    }
    
    fn realloc(self, ptr: u8*, new_size: usize) -> u8* {
        raw {
            return (uint8_t*) realloc(ptr, new_size);
        }
    }
    
    fn free(self, ptr: u8*) {
        raw {
            return free(ptr);
        }
    }
}

fn alloc<T>() -> T* {
    return (T*)malloc(sizeof(T));
}

fn zalloc<T>() -> T* {
    return (T*)calloc(1, sizeof(T));
}

fn alloc_n<T>(n: usize) -> T* {
    return (T*)malloc(sizeof(T) * n);
}

trait Drop {
    fn drop(self);
}

trait Copy {}

trait Clone {
    fn clone(self) -> Self;
}

struct Box<T> {
    ptr: T*;
}

impl Box<T> {
    fn new() -> Self {
        return Self { ptr: calloc(1, sizeof(T)) };
    }
    
    fn from_ptr(p: T*) -> Self {
        return Self { ptr: p };
    }
    
    fn ptr(self) -> T* {
        return self.ptr;
    }

    fn set(self, val: T) {
        *self.ptr = val;
    }

    fn get(self) -> T {
        return *self.ptr;
    }
    
    fn is_null(self) -> bool {
        return self.ptr == NULL;
    }
    
    fn free(self) {
        if self.ptr != NULL {
            free(self.ptr);
            self.ptr = NULL;
        }
    }
}

impl Drop for Box<T> {
    fn drop(self) {
        self.free();
    }
}

struct Slice<T> {
    data: T*;
    len: usize;
}

impl Slice<T> {
    fn new(data: T*, len: usize) -> Self {
        return Self { data: data, len: len };
    }
    
    fn get(self, i: usize) -> T {
        return self.data[i];
    }
    
    fn set(self, i: usize, val: T) {
        self.data[i] = val;
    }
    
    fn is_empty(self) -> bool {
        return self.len == 0;
    }
}

fn mem_zero<T>(ptr: T*, count: usize) {
    memset(ptr, 0, sizeof(T) * count);
}

fn mem_copy<T>(dst: T*, src: T*, count: usize) {
    memcpy(dst, src, sizeof(T) * count);
}

fn swap<T>(a: T*, b: T*) {
    var tmp = *a;
    *a = *b;
    *b = tmp;
}
