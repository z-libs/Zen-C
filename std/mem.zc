trait Allocator {
    fn allocate(self, size: usize) -> u8*;
    fn allocate_zeroed(self, size: usize) -> u8*;
    fn reallocate(self, ptr: u8*, new_size: usize) -> u8*;
    fn free(self, ptr: u8*, size: usize);
}

struct GeneralAllocator {}

impl Allocator for GeneralAllocator {
    fn allocate(self, size: usize) -> u8* {
        raw {
            return (uint8_t*) malloc(size);
        }
    }

    fn allocate_zeroed(self, size: usize) -> u8* {
        raw {
            return (uint8_t*) calloc(1, size);
        }
    }
    
    fn reallocate(self, ptr: u8*, new_size: usize) -> u8* {
        raw {
            return (uint8_t*) realloc(ptr, new_size);
        }
    }
    
    fn free(self, ptr: u8*) {
        raw {
            return free(ptr);
        }
    }
}

var GLOBAL_ALLOCATOR: GeneralAllocator;

@deprecated("Replaced with `Allocator::alloc`")
fn alloc<T>() -> T* {
    return (T*)malloc(sizeof(T));
}

@deprecated("Replaced with `Allocator`")
fn zalloc<T>() -> T* {
    return (T*)calloc(1, sizeof(T));
}

@deprecated("Replaced with `Allocator`")
fn alloc_n<T>(n: usize) -> T* {
    return (T*)malloc(sizeof(T) * n);
}

trait Drop {
    fn drop(self);
}

trait Copy {}

trait Clone {
    fn clone(self) -> Self;
}

struct Box<T> {
    ptr: T*;
}

impl Box<T> {
    fn new() -> Self {
        return Self { ptr: calloc(1, sizeof(T)) };
    }
    
    fn from_ptr(p: T*) -> Self {
        return Self { ptr: p };
    }
    
    fn get_ptr(self) -> T* {
        return self.ptr;
    }

    fn set(self, val: T) {
        *self.ptr = val;
    }

    fn get(self) -> T {
        return *self.ptr;
    }
    
    fn is_null(self) -> bool {
        return self.ptr == NULL;
    }
    
    fn free(self) {
        if self.ptr != NULL {
            free(self.ptr);
            self.ptr = NULL;
        }
    }
}

impl Drop for Box<T> {
    fn drop(self) {
        self.free();
    }
}


struct RcInner<T> {
    value: T;
    ref_count: usize;
}

struct Rc<T> {
    inner: RcInner<T>*;
}

impl Rc<T> {
    fn new(value: T) -> Self {
        var inner: RcInner<T>* = GLOBAL_ALLOCATOR.allocate(sizeof(RcInner<T>));

        inner.value = value;
        inner.ref_count = 1;

        return Self {
            inner: inner
        };
    }
}

impl Clone for Rc<T> {
    fn clone(self) -> Self {
        self.inner.ref_count++;
        
        return Self {
            inner: self.inner 
        };
    }
}

impl Drop for Rc<T> {
    fn drop(self) {
        self.inner.ref_count--;

        if (self.inner.ref_count == 0) {
            GLOBAL_ALLOCATOR.free(self.inner);
        }
    }
}

struct Slice<T> {
    data: T*;
    len: usize;
}

impl Slice<T> {
    fn new(data: T*, len: usize) -> Self {
        return Self { data: data, len: len };
    }
    
    fn get(self, i: usize) -> T {
        return self.data[i];
    }
    
    fn set(self, i: usize, val: T) {
        self.data[i] = val;
    }
    
    fn is_empty(self) -> bool {
        return self.len == 0;
    }
}

fn mem_zero<T>(ptr: T*, count: usize) {
    memset(ptr, 0, sizeof(T) * count);
}

fn mem_copy<T>(dst: T*, src: T*, count: usize) {
    memcpy(dst, src, sizeof(T) * count);
}

fn swap<T>(a: T*, b: T*) {
    var tmp = *a;
    *a = *b;
    *b = tmp;
}
