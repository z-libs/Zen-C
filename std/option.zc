
import "./core.zc"

struct Option<T> {
    is_some: bool;
    val: T;
}

impl Option<T> {
    fn Some(v: T) -> Option<T> {
         return Option<T> { is_some: true, val: v };
    }

    fn None() -> Option<T> {
         return Option<T> { is_some: false, val: 0 };
    }

    fn is_some(self) -> bool {
        return self.is_some;
    }

    fn is_none(self) -> bool {
        return !self.is_some;
    }

    fn forget(self) {
        memset(&self.val, 0, sizeof(T));
    }

    fn unwrap(self) -> T {
        if (!self.is_some) {
            !"Panic: unwrap called on None";
            exit(1);
        }
        let v = self.val;
        memset(&self.val, 0, sizeof(T));
        return v;
    }

    fn unwrap_ref(self) -> T* {
        if (!self.is_some) {
            !"Panic: unwrap_ref called on None";
            exit(1);
        }
        return &self.val;
    }
    
    fn unwrap_or(self, def_val: T) -> T {
        if (self.is_some) {
            return self.val;
        }
        return def_val;
    }
    
    fn expect(self, msg: char*) -> T {
        if (!self.is_some) {
            !"Panic: {msg}";
            exit(1);
        }
        return self.val;
    }
    
    fn or_else(self, other: Option<T>) -> Option<T> {
        if self.is_some { return *self; }
        return other;
    }
}
