
import "./core.zc"
import "./result.zc"
import "./string.zc"
import "./vec.zc"

raw {
    #include <dirent.h>
    #include <sys/stat.h>
    #include <unistd.h>
    
    // Helper to get file size for stat
    int _z_fs_get_metadata(char* path, uint64_t* size, int* is_dir, int* is_file) {
        struct stat st;
        if (stat(path, &st) != 0) return -1;
        *size = st.st_size;
        *is_dir = S_ISDIR(st.st_mode);
        *is_file = S_ISREG(st.st_mode);
        return 0;
    }
    
    // Thread-local storage for current directory path (for stat-based d_type fallback)
    static __thread char _z_fs_current_dir[1024] = {0};
    
    void _z_fs_set_dir_context(char* path) {
        strncpy(_z_fs_current_dir, path, sizeof(_z_fs_current_dir) - 1);
        _z_fs_current_dir[sizeof(_z_fs_current_dir) - 1] = '\0';
    }
    
    int _z_fs_read_entry(void* dir, char* out_name, int* is_dir) {
        struct dirent* ent = readdir((DIR*)dir);
        if (!ent) return 0;
        strcpy(out_name, ent->d_name);
        
        // Use d_type if available (most Unix systems), otherwise fallback to stat
        #if defined(_DIRENT_HAVE_D_TYPE) && defined(DT_DIR)
            if (ent->d_type != DT_UNKNOWN) {
                *is_dir = (ent->d_type == DT_DIR);
            } else
        #endif
        {
            // Fallback: use stat to determine if entry is a directory
            char fullpath[2048];
            snprintf(fullpath, sizeof(fullpath), "%s/%s", _z_fs_current_dir, ent->d_name);
            struct stat st;
            if (stat(fullpath, &st) == 0) {
                *is_dir = S_ISDIR(st.st_mode);
            } else {
                *is_dir = 0;
            }
        }
        return 1;
    }

    int _z_fs_mkdir(char* path) {
        #ifdef _WIN32
            return mkdir(path);
        #else
            return mkdir(path, 0777); 
        #endif
    }
}

extern fn _z_fs_mkdir(path: char*) -> int;
extern fn _z_fs_get_metadata(path: char*, size: U64*, is_dir: int*, is_file: int*) -> int;
extern fn _z_fs_read_entry(dir: void*, out_name: char*, is_dir: int*) -> int;
extern fn _z_fs_set_dir_context(path: char*) -> void;

struct File {
    handle: void*; // FILE*
}

struct Metadata {
    size: U64;
    is_dir: bool; 
    is_file: bool;
}

@derive(Eq)
struct DirEntry {
    name: String;
    is_dir: bool;
}

impl File {
    fn open(path: char*, mode: char*) -> Result<File> {
        var h = fopen(path, mode);
        if (h == NULL) {
            return Result<File>::Err("Failed to open file");
        }
        return Result<File>::Ok(File { handle: h });
    }
    
    fn close(self) {
        if (self.handle) {
            fclose(self.handle);
            self.handle = NULL;
        }
    }
    
    fn read_to_string(self) -> Result<String> {
        if (self.handle == NULL) return Result<String>::Err("File not open");
        
        fseek(self.handle, 0, SEEK_END);
        var size = ftell(self.handle);
        fseek(self.handle, 0, SEEK_SET);
        
        var buffer: char* = malloc((usize)size + 1);
        if (buffer == NULL) return Result<String>::Err("Out of memory");
        
        var read = fread(buffer, 1, size, self.handle);
        buffer[read] = 0;
        
        var s = String::new(buffer);
        free(buffer);
        return Result<String>::Ok(s);
    }
    
    fn read_all(path: char*) -> Result<String> {
        var res = File::open(path, "rb");
        if (res.is_err()) return Result<String>::Err(res.err);
        
        var f: File = res.unwrap();
        var s_res = f.read_to_string();
        f.close();
        return s_res;
    }
    
    fn write_string(self, content: char*) -> Result<bool> {
        if (self.handle == NULL) return Result<bool>::Err("File not open");
        var len = strlen(content);
        var written = fwrite(content, 1, len, self.handle);
        if (written != len) return Result<bool>::Err("Write incomplete");
        return Result<bool>::Ok(true);
    }
    
    fn exists(path: char*) -> bool {
        return access(path, F_OK) == 0;
    }
    
    fn metadata(path: char*) -> Result<Metadata> {
        var size: uint64_t;
        var is_d: int;
        var is_f: int;
        if (_z_fs_get_metadata(path, &size, &is_d, &is_f) != 0) {
            return Result<Metadata>::Err("Failed to get metadata");
        }
        return Result<Metadata>::Ok(Metadata { size: (U64)size, is_dir: is_d != 0, is_file: is_f != 0 });
    }
    
    fn create_dir(path: char*) -> Result<bool> {
        if (_z_fs_mkdir(path) != 0) return Result<bool>::Err("Failed to create directory");
        return Result<bool>::Ok(true);
    }
    
    fn remove_file(path: char*) -> Result<bool> {
        if (unlink(path) != 0) return Result<bool>::Err("Failed to remove file");
        return Result<bool>::Ok(true);
    }
    
    fn remove_dir(path: char*) -> Result<bool> {
        if (rmdir(path) != 0) return Result<bool>::Err("Failed to remove directory");
        return Result<bool>::Ok(true);
    }
    
    fn read_dir(path: char*) -> Result< Vec<DirEntry> > {
        var dir = opendir(path);
        if (dir == NULL) return Result< Vec<DirEntry> >::Err("Failed to open directory");
        
        // Set directory context for stat-based d_type fallback (Windows compatibility)
        _z_fs_set_dir_context(path);
        
        var entries = Vec<DirEntry>::new();
        var name_buf = malloc(256);
        var is_d: int = 0;
        
        while (_z_fs_read_entry(dir, name_buf, &is_d)) {
            // Skip . and ..
            if (strcmp(name_buf, ".") == 0 || strcmp(name_buf, "..") == 0) continue;
            
            entries.push(DirEntry {
                name: String::new(name_buf),
                is_dir: is_d != 0
            });
        }
        
        free(name_buf);
        closedir(dir);
        return Result< Vec<DirEntry> >::Ok(entries);
    }
}
